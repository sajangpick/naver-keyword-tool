# 🚀 Next.js 모던 스택 전환 최종 체크리스트 (Hardest, Best)

## 🎯 1. 프로젝트 목표 및 기본 구조 확정

Next.js 프로젝트로 **단일 통합**하여 성능, 유지보수성, 확장성을 극대화하는 것이 목표입니다.

| 목표 영역 | 전환 전략 | 유의 사항 |
| :--- | :--- | :--- |
| **프론트엔드** | Next.js (App Router 권장)로 UI 전면 재구성. | SSR/SSG 기능을 활용하여 성능 및 SEO 최적화. |
| **백엔드 로직** | Express 로직을 Next.js의 **API Routes**로 모두 이전/통합. | Express 서버 자체를 완전히 제거하고 Next.js만 사용. |
| **데이터베이스** | SQLite DB 파일 데이터를 **Supabase (PostgreSQL)**로 마이그레이션. | Vercel 배포 시 Supabase 연동이 간편하며, 실시간 기능 및 확장성 확보. |
| **배포** | 프로젝트 전체를 **Vercel**에 배포하여 최적화된 서버리스 환경 활용. | Render 배포 환경은 불필요해지며, Vercel의 CDN 및 서버리스 기능을 활용. |

---

## 🛠️ 2. 핵심 아키텍처 및 런타임 조정 (가장 중요)

Express 환경과 서버리스 환경의 근본적인 차이점을 해결하기 위한 필수 조정 사항입니다.

### 2.1 서버리스 환경 제약 대응

| 조정 항목 | Express 문제점 | Next.js 대응 방안 (유의사항) |
| :--- | :--- | :--- |
| **장시간 요청/타임아웃** ⚠️ | 30초 이상의 복잡한 AI 연동 작업 가능. | **Vercel 타임아웃(최대 10~30초) 고려:** 장시간 작업은 Next.js API Route에서 처리하지 말고, **Supabase Edge Functions + Queue 시스템** 등으로 분리하거나, 응답을 **스트리밍** 처리하도록 재설계. **Edge 런타임은 피하고 Node.js 런타임을 사용해야 함.** |
| **Python 스크립트 실행** ⚠️ | `child_process`로 `naver_place_scraper.py` 등 실행. | **서버리스 환경에서는 불가능/부적합:** 해당 로직을 **Node.js/TypeScript로 포팅**하거나, 별도의 **서버리스 워커** (예: AWS Lambda)로 분리하여 비동기 처리해야 함. |
| **라우팅 결정** | Express의 라우팅 구조. | **Next.js App Router (`app/`)** 또는 **Pages Router (`pages/api/`)** 중 선택. App Router의 **Route Handlers**(`app/api/*/route.ts`)가 최신 표준으로 권장됨. |
| **엔드포인트 매핑** | `/api/*` 경로. | **동일한 `/api/*` 경로를 유지**하여 기존 프론트엔드 코드의 수정 최소화. |

### 2.2 상태 및 보안 관리

| 조정 항목 | Express 문제점 | Next.js 대응 방안 (유의사항) |
| :--- | :--- | :--- |
| **레이트 리밋 (Rate Limit)** 🚨 | 메모리 `Map` 기반으로 서버리스 환경에서 동작 보장 불가. | **메모리 `Map` 방식 폐기!** Redis 또는 **Upstash** (Vercel에 최적화된 서버리스 Redis) 등 **외부 스토리지 기반**으로 레이트 리밋 로직을 전환하여 중앙 집중식으로 관리. |
| **환경 변수/보안** | `dotenv` 사용, 클라이언트 노출 위험. | **`.env.local`로 이전.** 서버 전용 키(`API Key`, `DB URL` 등)는 **절대 `NEXT_PUBLIC_` 접두사 사용 금지** (클라이언트에 노출됨). 배포 플랫폼(Vercel)의 환경 변수 관리 기능 사용. |

---

## 🏗️ 3. 코드 및 구조 재구성 (Refactoring)

기존 Express 미들웨어와 응답 방식을 Next.js 서버리스 환경에 맞게 전환해야 합니다.

| 조정 항목 | Express 문제점 | Next.js 대응 방안 |
| :--- | :--- | :--- |
| **미들웨어 재구성** | `app.use` 형태의 전역 미들웨어(CORS, 로깅, 본문 제한). | **CORS/로깅/본문 제한:** `middleware.ts` 또는 각 라우트 핸들러 내에서 처리. **본문 크기 제한**은 라우트 옵션으로 설정 (예: JSON 10MB). |
| **응답/에러 처리** | Express의 `res.json`, `res.status` 등. | **Web API 스타일로 전환:** App Router는 `new Response(JSON.stringify(data), { status: 200 })` 또는 Pages Router는 `NextApiResponse` 사용. **전역 에러 미들웨어 없음**에 유의하여 라우트별 `try/catch`와 표준 에러 포맷 통일. |
| **요청 파싱/유효성** | `req.body`를 바로 사용. | App Router는 `req.json()`으로, Pages Router는 `req.body` 기준으로 변경. **Zod** 라이브러리 등을 활용하여 바디 스키마 유효성 검증 로직 추가 권장. |
| **정적 자산/HTML** | Express의 정적 서빙. | Express 정적 서빙 제거. 모든 정적 파일(`CSS`, `이미지`, `폰트` 등)은 **`public/` 디렉토리**로 이전. 기존 HTML 파일은 Next.js 페이지(JSX/TSX)로 변환하거나 `public/`에서 직접 제공. |
| **헬스체크/운영** | `/health` 엔드포인트. | **`GET /api/health`** 라우트 추가 및 구조화 로깅 적용 (레벨/추적 ID 등). |

---

## 🏁 4. 클라이언트 및 배포 최종 점검

| 조정 항목 | 내용 |
| :--- | :--- |
| **외부 API 호출** | 기존 네이버, AI API 호출 로직의 타임아웃/재시도 설정을 점검하여 **서버리스 타임아웃 범위(최대 30초)** 내로 조정. |
| **클라이언트 네트워킹** | 동일 도메인 배치가 기본이 되므로 CORS 설정 단순화 가능. 프록시 환경의 **사용자 IP 획득**은 `x-forwarded-for` 헤더를 우선적으로 고려. |
| **배포 전략** | **Vercel**로 전환 시, Node 버전 및 패키지 매니저(npm/yarn/pnpm)를 프로젝트와 일치화. Vercel의 빌드·타임아웃·동시성 정책을 최종 확인. |