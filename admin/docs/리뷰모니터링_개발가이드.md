# 리뷰 모니터링 시스템 - 개발 가이드 (AI용)

> 🤖 **AI 개발자를 위한 완전 가이드**: 실제 요구사항 반영 완료

---

## 🎯 실제 요구사항 (중요!)

### **시스템 목표**
1. **회원이 플레이스 URL 등록** → 즉시 1차 전체 크롤링 → DB 저장 (기준점 생성, 알림 X)
2. **정기 크롤링** (하루 3회) → 새로운 리뷰만 수집 → DB 저장 → 조건부 알림 발송
3. **알림 발송 제어** → 어드민에서 회원별 1일 발송 횟수 제한 (0/1/2회)

### **크롤링 대상 (4가지 전부)**
- ✅ 방문자 리뷰 (visitor)
- ✅ 블로그 리뷰 (blog)
- ✅ 영수증 리뷰 (receipt)
- ✅ 새소식 (news)

### **알림 발송 조건**
- 저평점 리뷰 (1-2점) → 긴급 알림
- 고평점 리뷰 (5점) → 칭찬 알림
- **단, 1일 발송 횟수 제한 체크** (어드민 설정값)

---

## 📋 현재 상태

### ✅ 이미 완료된 것
- DB 스키마 기본 구조 (3개 테이블)
- API 엔드포인트 기본 구조
- 마이페이지/어드민 UI
- Vercel Cron 설정 (하루 3회)
- Puppeteer 이미 설치됨 (`package.json`에 있음)

### ⚠️ 작업 필요
1. **DB 스키마 추가** - 발송 제한 컬럼 3개
2. **크롤링 4종** - 방문자/블로그/영수증/새소식
3. **1차 크롤링 로직** - isFirstCrawl 구분
4. **발송 제한 로직** - 일일 한도 체크
5. **어드민 UI** - 발송 제어 설정

---

# Part 0: DB 스키마 수정 (최우선)

## 📌 작업 개요

**이유**: 발송 횟수 제한 기능을 위해 컬럼 3개 추가 필요

**파일**: 새로 생성 `database/schemas/features/review/review-monitoring-update.sql`

---

## Step 0-1: SQL 파일 생성

```sql
-- ============================================
-- 리뷰 모니터링 - 발송 제한 기능 추가
-- 작성일: 2025-10-30
-- ============================================

-- review_monitoring 테이블에 컬럼 추가
ALTER TABLE public.review_monitoring
ADD COLUMN IF NOT EXISTS daily_alert_limit integer DEFAULT 2,  -- 1일 발송 제한 (0=끄기, 1=1회, 2=2회)
ADD COLUMN IF NOT EXISTS alert_count_today integer DEFAULT 0,  -- 오늘 발송한 횟수
ADD COLUMN IF NOT EXISTS last_alert_date date;  -- 마지막 알림 발송 날짜 (자정 초기화용)

COMMENT ON COLUMN public.review_monitoring.daily_alert_limit IS '1일 최대 알림 발송 횟수 (0=알림끄기)';
COMMENT ON COLUMN public.review_monitoring.alert_count_today IS '오늘 발송한 알림 횟수';
COMMENT ON COLUMN public.review_monitoring.last_alert_date IS '마지막 알림 발송 날짜 (날짜 변경 시 alert_count_today 초기화)';

-- 인덱스 추가
CREATE INDEX IF NOT EXISTS idx_review_monitoring_alert_limit 
  ON public.review_monitoring(daily_alert_limit) 
  WHERE daily_alert_limit > 0;
```

---

## Step 0-2: Supabase에 적용

1. **Supabase Dashboard 접속**
2. **SQL Editor 메뉴 클릭**
3. **New Query 버튼**
4. **위 SQL 붙여넣기**
5. **Run 실행**
6. **확인**: `review_monitoring` 테이블에 컬럼 3개 추가됨

---

## Step 0-3: 체크리스트

- [ ] SQL 파일 생성
- [ ] Supabase에 SQL 실행
- [ ] 테이블에 컬럼 추가 확인
- [ ] Git 커밋
  ```bash
  git add database/schemas/features/review/review-monitoring-update.sql
  git commit -m "feat: 발송 제한 기능을 위한 DB 스키마 추가

  - daily_alert_limit: 1일 발송 제한 설정
  - alert_count_today: 오늘 발송 횟수
  - last_alert_date: 마지막 발송 날짜"
  ```

---

# Part 1: 네이버 플레이스 크롤링 구현 (4종 전체)

## 📌 작업 개요

**파일**: `api/review-monitoring.js`  
**현재**: 더미 데이터만 반환 (49-91줄)  
**목표**: 4종 크롤링 모두 구현

**⚠️ 중요**: Puppeteer는 이미 설치되어 있음! (`package.json`에 확인됨)

---

## Step 1-1: 기존 Puppeteer 코드 활용

**이미 있는 파일들:**
- `api/place-detail-crawl.js` - Chromium 설정 참고 가능
- `api/place-batch-crawl.js` - 브라우저 실행 로직 참고 가능

**설정 재사용:**
```javascript
// Vercel 환경 체크
const isVercel = process.env.VERCEL || process.env.NODE_ENV === "production";

let chromium, puppeteer;
if (isVercel) {
  chromium = require("@sparticuz/chromium");
  puppeteer = require("puppeteer-core");
} else {
  puppeteer = require("puppeteer");
}
```

---

## Step 1-2: 크롤링 함수 4개 작성

**파일 수정**: `api/review-monitoring.js` (49-91줄 삭제 후 교체)

**⚠️ 주의사항:**
1. `isFirstCrawl` 파라미터 추가 → true면 알림 안 보냄
2. 각 리뷰에 `external_id` 생성 → 중복 방지
3. 실패해도 계속 진행 (한 종류 실패해도 다른 것은 수집)

```javascript
// ========== 기존 49-91줄 삭제하고 아래로 교체 ==========

const isVercel = process.env.VERCEL || process.env.NODE_ENV === "production";

let chromium, puppeteer;
if (isVercel) {
  chromium = require("@sparticuz/chromium");
  puppeteer = require("puppeteer-core");
} else {
  puppeteer = require("puppeteer");
}

/**
 * 네이버 플레이스 리뷰 크롤링 (4종 전체)
 * @param {string} placeUrl - 플레이스 URL
 * @param {boolean} isFirstCrawl - 최초 크롤링 여부 (true면 알림 안 보냄)
 */
async function crawlPlaceReviews(placeUrl, isFirstCrawl = false) {
  let browser = null;
  
  try {
    console.log(`[크롤링 시작] ${placeUrl} (최초: ${isFirstCrawl})`);
    
    // 플레이스 ID 추출
    const placeId = extractPlaceId(placeUrl);
    if (!placeId) {
      throw new Error('유효하지 않은 플레이스 URL');
    }
    
    // 브라우저 실행
    let launchOptions;
    if (isVercel) {
      const executablePath = await chromium.executablePath();
      launchOptions = {
        args: [...chromium.args, "--no-sandbox", "--disable-setuid-sandbox"],
        defaultViewport: { width: 412, height: 915 },
        executablePath,
        headless: chromium.headless,
      };
    } else {
      launchOptions = {
        args: ["--no-sandbox", "--disable-setuid-sandbox"],
        defaultViewport: { width: 412, height: 915 },
        headless: true,
      };
    }
    
    browser = await puppeteer.launch(launchOptions);
    const page = await browser.newPage();
    await page.setUserAgent(
      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15'
    );
    
    // 4종 크롤링 (실패해도 계속 진행)
    const allReviews = [];
    
    // 1. 방문자 리뷰
    try {
      const visitorReviews = await crawlVisitorReviews(page, placeId);
      allReviews.push(...visitorReviews);
      console.log(`✅ 방문자 리뷰: ${visitorReviews.length}개`);
    } catch (error) {
      console.error('❌ 방문자 리뷰 크롤링 실패:', error.message);
    }
    
    // 2. 블로그 리뷰
    try {
      const blogReviews = await crawlBlogReviews(page, placeId);
      allReviews.push(...blogReviews);
      console.log(`✅ 블로그 리뷰: ${blogReviews.length}개`);
    } catch (error) {
      console.error('❌ 블로그 리뷰 크롤링 실패:', error.message);
    }
    
    // 3. 영수증 리뷰
    try {
      const receiptReviews = await crawlReceiptReviews(page, placeId);
      allReviews.push(...receiptReviews);
      console.log(`✅ 영수증 리뷰: ${receiptReviews.length}개`);
    } catch (error) {
      console.error('❌ 영수증 리뷰 크롤링 실패:', error.message);
    }
    
    // 4. 새소식
    try {
      const news = await crawlPlaceNews(page, placeId);
      allReviews.push(...news);
      console.log(`✅ 새소식: ${news.length}개`);
    } catch (error) {
      console.error('❌ 새소식 크롤링 실패:', error.message);
    }
    
    console.log(`[크롤링 완료] 총 ${allReviews.length}개 수집`);
    
    return {
      success: true,
      reviews: allReviews,
      total: allReviews.length,
      isFirstCrawl
    };
    
  } catch (error) {
    console.error('[크롤링 실패]', error);
    return {
      success: false,
      error: error.message,
      reviews: [],
      isFirstCrawl
    };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * 1. 방문자 리뷰 크롤링
 */
async function crawlVisitorReviews(page, placeId) {
  const url = `https://m.place.naver.com/restaurant/${placeId}/review/visitor`;
  await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
  await page.waitForTimeout(2000);
  
  const reviews = await page.evaluate(() => {
    const items = document.querySelectorAll('.list_review > li, .place_section_content li');
    const results = [];
    
    items.forEach((el, index) => {
      try {
        // 평점
        const stars = el.querySelectorAll('.star_score .star_fill, .rating_star .icon_star');
        const rating = stars ? stars.length : 0;
        
        // 내용
        const contentEl = el.querySelector('.review_text, .review_content');
        const content = contentEl ? contentEl.textContent.trim() : '';
        
        // 작성자
        const authorEl = el.querySelector('.reviewer_name, .user_name');
        const reviewer_name = authorEl ? authorEl.textContent.trim() : '익명';
        
        // 날짜
        const timeEl = el.querySelector('.review_time, .date');
        const timeText = timeEl ? timeEl.textContent.trim() : '';
        
        if (content) {
          results.push({
            type: 'visitor',
            external_id: `visitor_${placeId}_${Date.now()}_${index}`,
            rating,
            content,
            reviewer_name,
            reviewed_at: new Date().toISOString()
          });
        }
      } catch (err) {
        console.error('파싱 오류:', err);
      }
    });
    
    return results;
  });
  
  return reviews;
}

/**
 * 2. 블로그 리뷰 크롤링
 */
async function crawlBlogReviews(page, placeId) {
  const url = `https://m.place.naver.com/restaurant/${placeId}/review/ugc`;
  await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
  await page.waitForTimeout(2000);
  
  const reviews = await page.evaluate(() => {
    const items = document.querySelectorAll('.list_review > li, .place_section_content .item');
    const results = [];
    
    items.forEach((el, index) => {
      try {
        // 블로그는 평점 없음
        const rating = 0;
        
        // 내용
        const contentEl = el.querySelector('.review_text, .content');
        const content = contentEl ? contentEl.textContent.trim() : '';
        
        // 작성자 (블로그 제목)
        const titleEl = el.querySelector('.title, .blog_title');
        const reviewer_name = titleEl ? titleEl.textContent.trim() : '블로그';
        
        if (content && content.length > 10) {
          results.push({
            type: 'blog',
            external_id: `blog_${placeId}_${Date.now()}_${index}`,
            rating,
            content: content.substring(0, 500),
            reviewer_name,
            reviewed_at: new Date().toISOString()
          });
        }
      } catch (err) {
        console.error('파싱 오류:', err);
      }
    });
    
    return results;
  });
  
  return reviews;
}

/**
 * 3. 영수증 리뷰 크롤링
 */
async function crawlReceiptReviews(page, placeId) {
  const url = `https://m.place.naver.com/restaurant/${placeId}/review/receipt`;
  await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
  await page.waitForTimeout(2000);
  
  const reviews = await page.evaluate(() => {
    const items = document.querySelectorAll('.list_review > li, .place_section_content li');
    const results = [];
    
    items.forEach((el, index) => {
      try {
        // 평점
        const stars = el.querySelectorAll('.star_score .star_fill');
        const rating = stars ? stars.length : 0;
        
        // 내용
        const contentEl = el.querySelector('.review_text, .content');
        const content = contentEl ? contentEl.textContent.trim() : '';
        
        // 작성자
        const authorEl = el.querySelector('.reviewer_name, .user');
        const reviewer_name = authorEl ? authorEl.textContent.trim() : '영수증리뷰';
        
        if (content) {
          results.push({
            type: 'receipt',
            external_id: `receipt_${placeId}_${Date.now()}_${index}`,
            rating,
            content,
            reviewer_name,
            reviewed_at: new Date().toISOString()
          });
        }
      } catch (err) {
        console.error('파싱 오류:', err);
      }
    });
    
    return results;
  });
  
  return reviews;
}

/**
 * 4. 새소식 크롤링
 */
async function crawlPlaceNews(page, placeId) {
  const url = `https://m.place.naver.com/restaurant/${placeId}/feed`;
  await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
  await page.waitForTimeout(2000);
  
  const news = await page.evaluate(() => {
    const items = document.querySelectorAll('.place_section_content .item, .feed_item');
    const results = [];
    
    items.forEach((el, index) => {
      try {
        // 새소식은 평점 없음
        const rating = 0;
        
        // 내용
        const contentEl = el.querySelector('.text, .content');
        const content = contentEl ? contentEl.textContent.trim() : '';
        
        if (content && content.length > 10) {
          results.push({
            type: 'news',
            external_id: `news_${placeId}_${Date.now()}_${index}`,
            rating,
            content: content.substring(0, 500),
            reviewer_name: '사장님',
            reviewed_at: new Date().toISOString()
          });
        }
      } catch (err) {
        console.error('파싱 오류:', err);
      }
    });
    
    return results;
  });
  
  return news;
}
```

---

## Step 1-3: 1차 크롤링 로직 추가

**파일 수정**: `api/review-monitoring.js` (241-252줄 수정)

**현재 코드:**
```javascript
// 3. 새 리뷰 처리 (저장 + 알림)
for (const review of newReviews) {
  const result = await processNewReview(...);
}
```

**수정 후:**
```javascript
// 3. 새 리뷰 처리 (저장 + 알림)
let processedCount = 0;
for (const review of newReviews) {
  // ⚠️ isFirstCrawl이면 알림 안 보냄!
  const skipAlert = crawlResult.isFirstCrawl;
  
  const result = await processNewReview(
    monitoring.user_id,
    monitoring.id,
    monitoring,
    review,
    skipAlert  // 추가!
  );
  
  if (result.success) processedCount++;
}
```

---

## Step 1-4: processNewReview 함수 수정

**파일 수정**: `api/review-monitoring.js` (141-221줄)

**함수 시그니처 변경:**
```javascript
// 기존
async function processNewReview(userId, monitoringId, monitoring, review) {

// 변경 후
async function processNewReview(userId, monitoringId, monitoring, review, skipAlert = false) {
```

**알림 발송 부분 수정 (198줄 근처):**
```javascript
// 카카오톡 알림 발송
if (shouldSendAlert && !skipAlert) {  // skipAlert 체크 추가!
  const alertData = {
    id: alert.id,
    place_name: monitoring.place_name || '내 가게',
    place_url: monitoring.place_url,
    rating: review.rating,
    content: review.content,
    reviewer_name: review.reviewer_name,
    reviewed_at: review.reviewed_at
  };
  
  if (isUrgent) {
    await sendUrgentReviewAlert(userId, alertData);
  } else if (isHighRating) {
    await sendHighRatingAlert(userId, alertData);
  }
}

if (skipAlert) {
  console.log('[알림 건너뜀] 최초 크롤링');
}
```

---

## Step 1-5: 최초 크롤링 실행 시점

**파일 수정**: `api/review-monitoring.js` (516줄 근처)

**현재:**
```javascript
// 최초 크롤링 실행
setTimeout(() => crawlSingleMonitoring(data), 1000);
```

**수정 후:**
```javascript
// ✅ 최초 크롤링 실행 (isFirstCrawl = true)
setTimeout(async () => {
  // monitoring 객체에 isFirstCrawl 플래그 추가
  const monitoringWithFlag = { ...data, isFirstCrawl: true };
  await crawlSingleMonitoring(monitoringWithFlag);
}, 1000);
```

**crawlSingleMonitoring 함수 수정 (226줄):**
```javascript
async function crawlSingleMonitoring(monitoring) {
  const startTime = Date.now();
  
  try {
    console.log(`\n[크롤링 시작] ${monitoring.place_name || monitoring.place_url}`);
    
    // 1. 리뷰 크롤링 (isFirstCrawl 플래그 전달)
    const isFirstCrawl = monitoring.isFirstCrawl || false;
    const crawlResult = await crawlPlaceReviews(monitoring.place_url, isFirstCrawl);
    
    // ... 나머지 로직
```

---

## Step 1-6: 크롤링 체크리스트

- [ ] `crawlPlaceReviews()` 4종 크롤링 구현
- [ ] `crawlVisitorReviews()` 방문자 리뷰
- [ ] `crawlBlogReviews()` 블로그 리뷰
- [ ] `crawlReceiptReviews()` 영수증 리뷰
- [ ] `crawlPlaceNews()` 새소식
- [ ] `isFirstCrawl` 파라미터 추가
- [ ] `processNewReview()` skipAlert 추가
- [ ] 최초 크롤링 시점 수정
- [ ] 로컬 테스트 (선택)
- [ ] Git 커밋
  ```bash
  git add api/review-monitoring.js
  git commit -m "feat: 4종 크롤링 + 1차 크롤링 로직 구현

  - 방문자/블로그/영수증/새소식 크롤링
  - isFirstCrawl 플래그로 최초 크롤링 시 알림 안 보냄
  - 실패해도 다른 크롤링은 계속 진행"
  ```

---

# Part 2: 발송 횟수 제한 로직 추가

## 📌 작업 개요

**파일**: `api/kakao-alimtalk.js`  
**목표**: 알림 발송 전에 1일 한도 체크

**로직:**
1. 오늘 발송 횟수 확인
2. 날짜 바뀌면 카운트 초기화
3. 한도 초과 시 발송 안 함
4. 발송 성공 시 카운트 +1

---

## Step 2-1: 발송 제한 체크 함수 추가

**파일 수정**: `api/kakao-alimtalk.js` (맨 위에 추가)

```javascript
const { createClient } = require('@supabase/supabase-js');

// Supabase 클라이언트
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

/**
 * 발송 제한 체크 및 카운트 관리
 * @returns {object} { canSend: boolean, reason: string }
 */
async function checkAndUpdateAlertLimit(userId) {
  try {
    // 1. 현재 설정 조회
    const { data: monitoring, error } = await supabase
      .from('review_monitoring')
      .select('daily_alert_limit, alert_count_today, last_alert_date')
      .eq('user_id', userId)
      .single();
    
    if (error || !monitoring) {
      console.log('[발송 제한] 모니터링 설정 없음');
      return { canSend: false, reason: 'no_monitoring' };
    }
    
    // 2. 발송 제한이 0이면 알림 끄기
    if (monitoring.daily_alert_limit === 0) {
      console.log('[발송 제한] 알림 꺼짐 (limit=0)');
      return { canSend: false, reason: 'alert_disabled' };
    }
    
    // 3. 날짜 체크 (자정 지나면 초기화)
    const today = new Date().toISOString().split('T')[0];
    const lastDate = monitoring.last_alert_date 
      ? new Date(monitoring.last_alert_date).toISOString().split('T')[0]
      : null;
    
    let currentCount = monitoring.alert_count_today || 0;
    
    if (lastDate !== today) {
      // 날짜 바뀜 → 초기화
      console.log('[발송 제한] 날짜 변경, 카운트 초기화');
      currentCount = 0;
      
      await supabase
        .from('review_monitoring')
        .update({
          alert_count_today: 0,
          last_alert_date: today
        })
        .eq('user_id', userId);
    }
    
    // 4. 한도 체크
    if (currentCount >= monitoring.daily_alert_limit) {
      console.log(`[발송 제한] 오늘 한도 초과 (${currentCount}/${monitoring.daily_alert_limit})`);
      return { canSend: false, reason: 'daily_limit_exceeded' };
    }
    
    // 5. 발송 가능 → 카운트 +1
    console.log(`[발송 제한] 발송 가능 (${currentCount + 1}/${monitoring.daily_alert_limit})`);
    
    await supabase
      .from('review_monitoring')
      .update({
        alert_count_today: currentCount + 1,
        last_alert_date: today
      })
      .eq('user_id', userId);
    
    return { canSend: true, reason: 'ok' };
    
  } catch (error) {
    console.error('[발송 제한 체크 실패]', error);
    return { canSend: false, reason: 'error' };
  }
}
```

---

## Step 2-2: sendUrgentReviewAlert 함수 수정

**파일 수정**: `api/kakao-alimtalk.js` (137-181줄)

**기존 함수 맨 앞에 추가:**
```javascript
async function sendUrgentReviewAlert(userId, alertData) {
  try {
    console.log('[알림톡] 긴급 리뷰 발송 시도:', alertData.id);
    
    // ✅ 발송 제한 체크 (맨 앞에 추가!)
    const limitCheck = await checkAndUpdateAlertLimit(userId);
    if (!limitCheck.canSend) {
      console.log(`[알림톡 건너뜀] ${limitCheck.reason}`);
      return { success: false, reason: limitCheck.reason };
    }
    
    // 사용자 전화번호 가져오기
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('phone_number')
      .eq('id', userId)
      .single();
    
    // ... 나머지 코드 동일
```

---

## Step 2-3: sendHighRatingAlert 함수 수정

**파일 수정**: `api/kakao-alimtalk.js` (186-225줄)

**똑같이 맨 앞에 추가:**
```javascript
async function sendHighRatingAlert(userId, alertData) {
  try {
    console.log('[알림톡] 고평점 리뷰 발송 시도:', alertData.id);
    
    // ✅ 발송 제한 체크
    const limitCheck = await checkAndUpdateAlertLimit(userId);
    if (!limitCheck.canSend) {
      console.log(`[알림톡 건너뜀] ${limitCheck.reason}`);
      return { success: false, reason: limitCheck.reason };
    }
    
    // ... 나머지 코드 동일
```

---

## Step 2-4: sendDailySummary 함수 수정

**파일 수정**: `api/kakao-alimtalk.js` (230-260줄)

**⚠️ 주의**: 일일 요약은 발송 제한에서 제외할지 결정 필요

**옵션 A: 일일 요약도 제한 적용**
```javascript
async function sendDailySummary(userId, summaryData) {
  try {
    // 발송 제한 체크
    const limitCheck = await checkAndUpdateAlertLimit(userId);
    if (!limitCheck.canSend) {
      return { success: false, reason: limitCheck.reason };
    }
    // ...
```

**옵션 B: 일일 요약은 제한 없음 (추천)**
```javascript
async function sendDailySummary(userId, summaryData) {
  try {
    // 발송 제한 체크 안 함 (일일 요약은 항상 발송)
    console.log('[알림톡] 일일 요약 발송 (제한 없음)');
    // ...
```

---

## Step 2-5: 발송 제한 체크리스트

- [ ] `checkAndUpdateAlertLimit()` 함수 작성
- [ ] `sendUrgentReviewAlert()` 수정
- [ ] `sendHighRatingAlert()` 수정
- [ ] `sendDailySummary()` 제한 여부 결정
- [ ] Git 커밋
  ```bash
  git add api/kakao-alimtalk.js
  git commit -m "feat: 알림톡 발송 횟수 제한 기능 추가

  - checkAndUpdateAlertLimit() 함수
  - 날짜 변경 시 자동 초기화
  - 1일 한도 초과 시 발송 안 함
  - 발송 성공 시 카운트 자동 증가"
  ```

---

# Part 3: 어드민 발송 제어 UI 추가

## 📌 작업 개요

**파일**: `admin/review-monitoring.html`  
**목표**: 회원별 발송 횟수 설정 UI 추가

---

## Step 3-1: UI 추가

**파일 수정**: `admin/review-monitoring.html` (적당한 위치에 추가)

**테이블에 컬럼 추가:**
```html
<!-- 기존 테이블 <thead> 수정 -->
<thead>
  <tr>
    <th>사용자</th>
    <th>플레이스</th>
    <th>상태</th>
    <th>마지막 크롤링</th>
    <th>발송 제한</th> <!-- 추가! -->
    <th>오늘 발송</th> <!-- 추가! -->
    <th>작업</th>
  </tr>
</thead>
```

**테이블 행 렌더링 수정:**
```javascript
// JavaScript에서 테이블 행 생성 부분
function renderMonitoringRow(monitoring) {
  return `
    <tr>
      <td>${monitoring.user_email || monitoring.user_id}</td>
      <td>${monitoring.place_name || '-'}</td>
      <td>${monitoring.monitoring_enabled ? '활성' : '비활성'}</td>
      <td>${formatDate(monitoring.last_crawled_at)}</td>
      
      <!-- 발송 제한 설정 -->
      <td>
        <select 
          class="alert-limit-select" 
          data-user-id="${monitoring.user_id}"
          onchange="updateAlertLimit(this)"
        >
          <option value="0" ${monitoring.daily_alert_limit === 0 ? 'selected' : ''}>
            알림 끄기
          </option>
          <option value="1" ${monitoring.daily_alert_limit === 1 ? 'selected' : ''}>
            1일 1회
          </option>
          <option value="2" ${monitoring.daily_alert_limit === 2 ? 'selected' : ''}>
            1일 2회
          </option>
        </select>
      </td>
      
      <!-- 오늘 발송 횟수 -->
      <td>
        <span class="alert-count">
          ${monitoring.alert_count_today || 0} / ${monitoring.daily_alert_limit}
        </span>
      </td>
      
      <td>
        <button onclick="manualCrawl('${monitoring.id}')">크롤링</button>
      </td>
    </tr>
  `;
}
```

---

## Step 3-2: JavaScript 함수 추가

**파일 수정**: `admin/review-monitoring.html` (스크립트 섹션)

```javascript
/**
 * 발송 제한 설정 업데이트
 */
async function updateAlertLimit(selectElement) {
  const userId = selectElement.dataset.userId;
  const newLimit = parseInt(selectElement.value);
  
  if (!confirm(`발송 제한을 ${newLimit === 0 ? '알림 끄기' : `1일 ${newLimit}회`}로 변경하시겠습니까?`)) {
    return;
  }
  
  try {
    // Supabase 업데이트
    const { error } = await supabase
      .from('review_monitoring')
      .update({
        daily_alert_limit: newLimit
      })
      .eq('user_id', userId);
    
    if (error) throw error;
    
    alert('✅ 발송 제한이 변경되었습니다!');
    
    // 테이블 새로고침
    loadMonitoringList();
    
  } catch (error) {
    console.error('발송 제한 변경 실패:', error);
    alert('❌ 변경 실패: ' + error.message);
  }
}

/**
 * 모니터링 목록 로드 (기존 함수 수정)
 */
async function loadMonitoringList() {
  try {
    // ⚠️ SELECT에 새 컬럼 3개 추가!
    const { data, error } = await supabase
      .from('review_monitoring')
      .select(`
        *,
        daily_alert_limit,
        alert_count_today,
        last_alert_date
      `)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    
    // 테이블 렌더링
    const tbody = document.getElementById('monitoringTableBody');
    tbody.innerHTML = data.map(m => renderMonitoringRow(m)).join('');
    
  } catch (error) {
    console.error('목록 로드 실패:', error);
  }
}
```

---

## Step 3-3: CSS 스타일 추가

**파일 수정**: `admin/review-monitoring.html` (스타일 섹션)

```css
/* 발송 제한 셀렉트 */
.alert-limit-select {
  padding: 6px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
}

.alert-limit-select:hover {
  border-color: #03c75a;
}

/* 오늘 발송 횟수 */
.alert-count {
  padding: 4px 8px;
  background: #f0f0f0;
  border-radius: 4px;
  font-size: 13px;
  font-weight: 500;
}
```

---

## Step 3-4: 어드민 UI 체크리스트

- [ ] 테이블에 "발송 제한" 컬럼 추가
- [ ] 테이블에 "오늘 발송" 컬럼 추가
- [ ] 발송 제한 셀렉트 박스 추가
- [ ] `updateAlertLimit()` 함수 작성
- [ ] `loadMonitoringList()` SELECT 수정
- [ ] CSS 스타일 추가
- [ ] Git 커밋
  ```bash
  git add admin/review-monitoring.html
  git commit -m "feat: 어드민 발송 제어 UI 추가

  - 회원별 발송 제한 설정 (0/1/2회)
  - 오늘 발송 횟수 표시
  - 실시간 업데이트"
  ```

---

# 🧪 통합 테스트 플로우

## Test 1: 회원 등록 시 1차 크롤링

```
1. 마이페이지 접속
2. 플레이스 URL 입력
   예: https://m.place.naver.com/restaurant/1390003666
3. "저장" 클릭
4. [예상] 백그라운드에서 크롤링 시작
5. [예상] DB에 리뷰 저장됨 (알림 안 옴!)
6. [확인] Supabase → review_alerts 테이블 확인
```

---

## Test 2: 정기 크롤링 및 알림

```
1. 어드민 페이지 접속
2. "수동 크롤링 실행" 클릭
3. [예상] 새 리뷰만 수집
4. [예상] 저평점/고평점 리뷰에 알림 발송
5. [확인] 카카오톡 수신 확인
6. [확인] 오늘 발송 횟수 증가
```

---

## Test 3: 발송 제한 테스트

```
1. 어드민에서 특정 회원 "1일 1회"로 설정
2. 수동 크롤링 실행 → 알림 1개 발송
3. [예상] alert_count_today = 1
4. 다시 크롤링 실행 → 새 리뷰 있어도 알림 안 옴
5. [로그 확인] "오늘 한도 초과" 메시지
6. 다음날 00:00 이후 → 자동 초기화
```

---

# 📊 완료 체크리스트

## Part 0: DB 스키마
- [ ] SQL 파일 생성
- [ ] Supabase에 실행
- [ ] 컬럼 3개 확인
- [ ] Git 커밋

## Part 1: 크롤링
- [ ] 4종 크롤링 함수 작성
- [ ] isFirstCrawl 로직 추가
- [ ] processNewReview skipAlert 추가
- [ ] 최초 크롤링 실행 수정
- [ ] Git 커밋

## Part 2: 발송 제한
- [ ] checkAndUpdateAlertLimit 함수
- [ ] sendUrgentReviewAlert 수정
- [ ] sendHighRatingAlert 수정
- [ ] sendDailySummary 결정
- [ ] Git 커밋

## Part 3: 어드민 UI
- [ ] 테이블 컬럼 추가
- [ ] 발송 제한 셀렉트
- [ ] updateAlertLimit 함수
- [ ] CSS 스타일
- [ ] Git 커밋

## 통합 테스트
- [ ] 1차 크롤링 테스트
- [ ] 정기 크롤링 테스트
- [ ] 발송 제한 테스트
- [ ] 카카오톡 알림 수신
- [ ] Cron 자동 실행 확인

---

# 🔗 관련 파일 위치

```
database/schemas/features/review/
├── review-monitoring.sql (기존)
└── review-monitoring-update.sql (신규) ← Part 0

api/
├── review-monitoring.js ← Part 1 (크롤링)
└── kakao-alimtalk.js ← Part 2 (발송 제한)

admin/
└── review-monitoring.html ← Part 3 (UI)
```

---

# ⚠️ 중요 주의사항 (AI 필독!)

## 1. Puppeteer 설치 불필요
- 이미 `package.json`에 있음
- 추가 설치 명령 실행하지 마세요

## 2. 셀렉터 변경 가능성
- 네이버 플레이스 HTML 구조가 자주 바뀜
- 크롤링 실패 시 셀렉터 업데이트 필요
- 개발자 도구로 최신 구조 확인

## 3. 발송 제한 로직 순서
- 반드시 checkAndUpdateAlertLimit 먼저 호출
- 전화번호 조회보다 먼저 체크해야 함
- 순서 바뀌면 카운트가 잘못 증가함

## 4. 1차 크롤링 플래그
- isFirstCrawl은 monitoring 객체에만 추가
- DB에 저장하지 않음 (임시 플래그)
- crawlSingleMonitoring 함수 내부에서만 사용

## 5. 날짜 초기화 타이밍
- last_alert_date는 날짜만 비교 (시간 제외)
- toISOString().split('T')[0] 사용
- 자정 기준으로 자동 초기화됨

---

**작성일**: 2025-10-30  
**최종 수정**: 2025-10-30  
**작성자**: 실제 요구사항 반영 완료  
**AI**: 이 가이드를 순서대로 따라하세요. 모든 함정 포인트가 표시되어 있습니다.
